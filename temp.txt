public class DriveSubsystem extends SubsystemBase {
  public DriveSubsystem() {
      // Configure AutoBuilder
      AutoBuilder.configureHolonomic(
        this::getPose, 
        this::resetOdometry, 
        this::getSpeeds, 
        this::driveRobotRelative, 
        Constants.DriveConstants.pathFollowerConfig,
        () -> {
            // Boolean supplier that controls when the path will be mirrored for the red alliance
            // This will flip the path being followed to the red side of the field.
            // THE ORIGIN WILL REMAIN ON THE BLUE SIDE

            var alliance = DriverStation.getAlliance();
            if (alliance.isPresent()) {
                return alliance.get() == DriverStation.Alliance.Red;
            }
            return false;
        },
        this
      );
  }
}

â€ƒ
  public Pose2d getPose() {
    Pose2d pose = m_odometry.getPoseMeters();
    return pose;
  }
  
  public void resetOdometry(Pose2d pose) {
    m_odometry.resetPosition(
        Rotation2d.fromDegrees(m_gyro.getAngle() * (DriveConstants.kGyroReversed ? -1.0 : 1.0)),

        //bIrobot Note: IMUAxis.kz was NOT in the parens above in the 2023 code
        //end note

        new SwerveModulePosition[] {
            m_frontLeft.getPosition(),
            m_frontRight.getPosition(),
            m_rearLeft.getPosition(),
            m_rearRight.getPosition()
        },
        pose);
  }
  
  public ChassisSpeeds getSpeeds() {
    return Constants.DriveConstants.kDriveKinematics.toChassisSpeeds(
      m_frontLeft.getState(), m_frontRight.getState(), m_rearLeft.getState(), m_rearRight.getState()
    );
  }

  public void driveRobotRelative(ChassisSpeeds robotRelativeSpeeds) {
    drive(robotRelativeSpeeds.vxMetersPerSecond/Constants.DriveConstants.kMaxSpeedMetersPerSecond,
          robotRelativeSpeeds.vyMetersPerSecond/Constants.DriveConstants.kMaxSpeedMetersPerSecond,
          robotRelativeSpeeds.omegaRadiansPerSecond/Constants.DriveConstants.kMaxAngularSpeed,
          false, true);
  }







public RobotContainer() {
    // Calls the pathplanner file
    public Command getAutonomousCommand() {
        return autoChooser.getSelected();
    }
}

public class Robot extends TimedRobot {
  public void autonomousInit() {
    m_autonomousCommand = m_robotContainer.getAutonomousCommand();
    if (m_autonomousCommand != null) {
      System.out.println("WE HAVE A Command!!!");
      m_autonomousCommand.schedule();
    }
  }
}

